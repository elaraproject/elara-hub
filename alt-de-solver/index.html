
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elara Hub</title>
    
    <link rel="stylesheet" href="https://elaraproject.github.io/elara-hub/index.css">
    <!--KaTeX-->
    <link rel="stylesheet" href="https://elaraproject.github.io/elara-hub/katex/katex.min.css">

    <!--Open Sans-->
    <link rel="stylesheet" href="https://elaraproject.github.io/elara-hub/open-sans/open-sans.css">
    
</head>
<body>
    <nav>
    	<span class="header active">
    		<a href="https://elaraproject.github.io/elara-hub">Elara Hub</a> :: <a href="https://elaraproject.github.io/elara-hub/elara-hub-index/">Home</a>
    	</span>
    	<a class="header mobile-only" href="https://elaraproject.github.io/elara-hub/menu/">Menu</a>
    	<ul>
    	 
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/6-month-roadmap-1/">6-month roadmap 1</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/all-about-pdes/">All about partial differential equations</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/alt-de-solver/">Alternate differential equation solver</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/black-hole-raytracing/">Black hole raytracing</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/elara-gfx-continuing-work/">Elara GFX continuing work plan</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/elara-hub-creation/">Elara Hub creation plan</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/elara-hub-index/">Elara Hub Index</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/meta/">Elara Hub Meta</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/markdown-guide/">Elara markdown guide</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/elara-math-optimization/">Elara math optimization strategies</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/elara-ml-api/">Elara ML API proposal</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/elara-array-api-plan/">Elara-array API</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/extra/">Extra content</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/focusing-chamber-1/">Focusing chamber theoretical analysis 1</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/geometrized/">Geometrized units</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/h2-co2/">Hydrogen from CO2 production</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/integration-techniques/">Integration techniques</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/menu/">Menu (for mobile)</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/multivar/">Multivariable calculus guide</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/stages/">Project development stages</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/app-plans/">Project Elara app plans</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/library-plans/">Project Elara library plans</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/outreach-plan/">Project Elara Outreach Plan</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/funny/">Project humour and jokes</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/project-philosophy/">Project Philosophy</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/eval-christoffels/">Quickly evaluating the Christoffel symbols</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/relativity-hub/">Relativity Hub</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/future-extensions/">Speculative future extensions</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/standard-notation/">Standardized calculus notation</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/handbook-addthings/">Things to add to Elara Handbook</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/visualization-outreach/">Visualization-based outreach</a></li>
    	 
    	</ul>
    </nav>

    <main>
    	<article>
	    
	<h1>Alternate differential equation solver</h1>
	<!--eventually add in authors-->
	<p>&quot;New&quot; way to solve ODEs and PDEs that DOESN'T involve complicated computations or matrices (actually not new at all, but it might have potential):</p>
<p>Just use Taylor series and automatic differentiation. Consider, for example, the ODE:</p>
<p>$$
\frac{dy}{dx} = 3y + 2x^2, y(0) = 3
$$</p>
<p>$$
y'' = 3y' + 4x, y' = 9
$$
$$
y''' = 3y'' + 4, y'' = 27
$$
$$
y''' = 3y''', y''=85
$$</p>
<p>You can construct a Taylor series around the point $x = 0$ to approximate a solution $y(x)$ of the ODE, then use automatic differentiation to compute successive derivatives to refine that approximation. This approach doesn't have numerical precision errors, and it can be made arbitrarily precise, and also doesn't require complicated grids. And it can be extended for partial differential equations - you do the same, just with the partial derivatives version of Taylor series. And this works on all analytic functions, even non-elementary functions, so it's especially well-suited to arbitrary differential equations. The solver can use the Taylor remainder theorem to automatically choose the number of terms for the approximation to be within a specified maximum error tolerance.</p>
<p>For the Taylor series to be maximally accurate even at points far from the source, multiple taylor series is used. A new point $x_1$ is chosen based on the most distant point from the original point $x_0$ that satisfies the maximum error as defined by the Taylor remainder theorem. Then a new taylor series is constructed from the point $x_1$. This process can be repeated multiple times to generate an effective solution for all points requested.</p>
<p>(Note: there are definitely optimizations that can be done to make the Taylor series converge faster while retaining the same algorithm for ODE/PDE solving, but that is for another time.)</p>
<p>Ways to speed up taylor series approx to diff eq:</p>
<ul>
<li>Computing more terms</li>
<li>Range reduction</li>
<li>Using multiple overlapping taylor series computed by constructing a new taylor series from a point evaluated by an existing one</li>
</ul>
<p>Note that multiple overlapping taylor series isn't runge kutta or euler because it computes derivatives of the derivative via autodiff, instead of using a single derivative.</p>
<hr />
<p>To create a very basic implementation of this method and show that it solves a first-order ODE accurately, I will use a dual-number based autodiff. So the code will be like this:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">struct </span><span>Num {
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">val</span><span>: </span><span style="color:#b48ead;">f64</span><span>,
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">eps</span><span>: </span><span style="color:#b48ead;">f64</span><span>,
</span><span>}
</span><span>
</span><span style="color:#b48ead;">impl </span><span>Num {
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">from</span><span>(</span><span style="color:#bf616a;">val</span><span>: </span><span style="color:#b48ead;">f64</span><span>, </span><span style="color:#bf616a;">eps</span><span>: </span><span style="color:#b48ead;">f64</span><span>) -&gt; Num {
</span><span>        Value {
</span><span>            val, eps
</span><span>        }
</span><span>    }
</span><span>	
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">cos</span><span>(</span><span style="color:#bf616a;">self</span><span>) -&gt; Num {
</span><span>        Value::from(</span><span style="color:#bf616a;">self</span><span>.</span><span style="color:#96b5b4;">cos</span><span>(), -</span><span style="color:#bf616a;">self</span><span>.eps * </span><span style="color:#bf616a;">self</span><span>.eps.</span><span style="color:#96b5b4;">sin</span><span>())
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">diff</span><span>(</span><span style="color:#bf616a;">func</span><span>: |Num| -&gt; Num, </span><span style="color:#bf616a;">x0</span><span>: </span><span style="color:#b48ead;">f64</span><span>) -&gt; </span><span style="color:#b48ead;">f64 </span><span>{
</span><span>    </span><span style="color:#b48ead;">let</span><span> x = Num::from(x0, </span><span style="color:#d08770;">1.0</span><span>);
</span><span>    </span><span style="color:#96b5b4;">func</span><span>(x).eps
</span><span>}
</span><span>
</span><span style="color:#65737e;">// Usage: diff(|x| x.cos(), PI);
</span></code></pre>
<p>The way to make this work is that on calling <code>solve()</code>, the solver evaluates the solution at every point in the domain by constructing a Taylor polynomial (of 10th-order default); if the point in question is evaluated via Taylor remainder theorem and found to be too inaccurate, then a new Taylor series approximation is constructed at that point using the best approximate values from the previous series (and automatic differentiation), and the evaluator uses that new Taylor series to solve for the remaining points.</p>


	    </article>
    </main>

    <script>
    // Necessary until pulldown-cmark (which Zola depends on)
    // auto-appends a .tasklist class to all list items
    // that contain task lists
    document.querySelectorAll("input[type='checkbox']").forEach((el) => el.parentElement.classList.add("tasklist"));
    </script>

    <script defer src="https://elaraproject.github.io/elara-hub/katex/katex.min.js"></script>
    <script defer src="https://elaraproject.github.io/elara-hub/katex/contrib/auto-render.min.js"></script>

    <script>
    	// Loading KaTeX
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
              // customised options
              // • auto-render specific keys, e.g.:
              delimiters: [
                  {left: '$$', right: '$$', display: true},
                  {left: '$', right: '$', display: false},
                  {left: '\\(', right: '\\)', display: false},
                  {left: '\\[', right: '\\]', display: true}
              ],
              // • rendering keys, e.g.:
              throwOnError : false
            });
        });
    </script>
</body>
</html>
