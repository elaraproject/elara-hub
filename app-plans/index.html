
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elara Hub</title>
    
    <link rel="stylesheet" href="https://elaraproject.github.io/elara-hub/index.css">
    <!--KaTeX-->
    <link rel="stylesheet" href="https://elaraproject.github.io/elara-hub/katex/katex.min.css">

    <!--Open Sans-->
    <link rel="stylesheet" href="https://elaraproject.github.io/elara-hub/open-sans/open-sans.css">
    
</head>
<body>
    <nav>
    	<span class="header active">
    		<a href="https://elaraproject.github.io/elara-hub">Elara Hub</a> :: <a href="https://elaraproject.github.io/elara-hub/elara-hub-index/">Home</a>
    	</span>
    	<a class="header mobile-only" href="https://elaraproject.github.io/elara-hub/menu/">Menu</a>
    	<ul>
    	 
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/6-month-roadmap-1/">6-month roadmap 1</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/all-about-pdes/">All about partial differential equations</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/alt-de-solver/">Alternate differential equation solver</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/black-hole-raytracing/">Black hole raytracing</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/elara-gfx-continuing-work/">Elara GFX continuing work plan</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/elara-hub-creation/">Elara Hub creation plan</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/elara-hub-index/">Elara Hub Index</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/meta/">Elara Hub Meta</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/markdown-guide/">Elara markdown guide</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/elara-math-optimization/">Elara math optimization strategies</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/elara-ml-api/">Elara ML API proposal</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/elara-array-api-plan/">Elara-array API</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/extra/">Extra content</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/focusing-chamber-1/">Focusing chamber theoretical analysis 1</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/geometrized/">Geometrized units</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/h2-co2/">Hydrogen from CO2 production</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/integration-techniques/">Integration techniques</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/menu/">Menu (for mobile)</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/multivar/">Multivariable calculus guide</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/stages/">Project development stages</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/app-plans/">Project Elara app plans</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/library-plans/">Project Elara library plans</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/outreach-plan/">Project Elara Outreach Plan</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/funny/">Project humour and jokes</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/project-philosophy/">Project Philosophy</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/eval-christoffels/">Quickly evaluating the Christoffel symbols</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/relativity-hub/">Relativity Hub</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/future-extensions/">Speculative future extensions</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/standard-notation/">Standardized calculus notation</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/handbook-addthings/">Things to add to Elara Handbook</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/visualization-outreach/">Visualization-based outreach</a></li>
    	 
    	</ul>
    </nav>

    <main>
    	<article>
	    
	<h1>Project Elara app plans</h1>
	<!--eventually add in authors-->
	<p>Note: all of these apps follow a core-frontend architecture. That is, their entire functionalities are exposed via a <em>core library</em> (e.g. <code>libde</code> for Elara DE and <code>libgeod</code> for Elara Geo), and the frontend is just the UI. </p>
<p>Project Elara apps have UIs but many have an additional python REPL with a live preview window by default. The entire app's functions is accessible via REPL thanks to the core-frontend architecture.</p>
<h2 id="elara-geo">elara-geo</h2>
<p>Rust reimplementation of <a href="https://github.com/tauzero7/GeodesicViewer">https://github.com/tauzero7/GeodesicViewer</a></p>
<h2 id="elara-compute-euler">elara-compute (&quot;Euler&quot;)</h2>
<p>A numerical computing environment that feels like symbolic computation, based on <a href="https://github.com/chebfun/chebfun">https://github.com/chebfun/chebfun</a>.</p>
<h2 id="elara-de-principia">elara-DE (&quot;Principia&quot;)</h2>
<p>Make automated ODE and PDE solver. It should have the following features:</p>
<ul>
<li>Handle either single DE or system of DEs of any order</li>
<li>Support multivariable or single-variable scalar, vector, or tensor-valued function (or field) to solve for, as well as real or complex arguments</li>
<li>Enter in ODE or PDE as with as boundary/initial conditions symbolically (with SymPy-like syntax)</li>
<li>(Optional) compare solution to manually-inputted analytical solution</li>
<li>GPU acceleration for fast solving</li>
<li>Slope fields for first-order ODEs</li>
<li>Built-in visualization tools for solutions (defaults to lines for single-variable functions, heatmaps for two-variable (3D) functions, and density plots for three-variable (4D) functions, with the colors automatically scaled based on max intensity and the opacity of each pixel scaled based on the inputted grid density)</li>
<li>Has both a PINN (neural-network based) solver and a conventional grid-based solver.
Elara DE's planned API:</li>
</ul>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#65737e;">// example DE solving
</span><span>x, y, z = var!(x, y, z);
</span><span>k = </span><span style="color:#b48ead;">const</span><span>!(k = </span><span style="color:#d08770;">5</span><span>);
</span><span>
</span><span style="color:#65737e;">// ODE example
</span><span style="color:#b48ead;">let</span><span> f = </span><span style="color:#d08770;">DE</span><span>::fn(&quot;</span><span style="color:#a3be8c;">f</span><span>&quot;, x);
</span><span style="color:#b48ead;">let</span><span> dfdx = </span><span style="color:#96b5b4;">diff</span><span>(f, x);
</span><span style="color:#b48ead;">let</span><span> eq = diffeq![dfdx = </span><span style="color:#d08770;">3 </span><span>* k * y];
</span><span>eq.</span><span style="color:#96b5b4;">set_initial</span><span>();
</span><span>eq.</span><span style="color:#96b5b4;">dsolve</span><span>();
</span></code></pre>
<p>Elara-DE will have three solvers - Taylor series/autodiff solver, grid-based solver, and NN solver. Each has its advantages and disadvantages:</p>
<ul>
<li>Taylor solver &amp; NN solver don't have curse of dimensionality, are much faster, and can compute values at an arbitrary point in the domain (because they return functions, not discrete arrays)
<ul>
<li>Taylor solver is probably faster</li>
<li>NN solver is much more well-proven and may be more accurate</li>
</ul>
</li>
<li>Grid-based solver isn't as finnicky as PINN (because training neural networks to predict accurately is an art as much as a science, you have to consider things like learning rate, overfitting, etc. whereas grid solver gives you dependable results every time) and unlike Taylor solver, it can solve for implicit as well as explicit solutions</li>
</ul>
<p>Of these I'll make the Taylor solver and grid solver first, and PINN last as neural networks are very finnicky to train.</p>
<h2 id="elara-cas">elara-cas</h2>
<p>(note: awaiting better name)</p>
<p>elara-cas is a Qalculate replacement, with LaTeX printing output, a syntax-highlighted REPL, and an optional visual editor for inserting complicating expressions. </p>
<p>Elara CAS will use integral/diff eq solver from <a href="https://arxiv.org/abs/1912.01412">https://arxiv.org/abs/1912.01412</a></p>
<p>UI inspired by <a href="https://github.com/bornova/numara-calculator">https://github.com/bornova/numara-calculator</a></p>
<p>This should be the syntax:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#65737e;">// Basic calculations (these are done symbolically)
</span><span style="color:#d08770;">1 </span><span>+ </span><span style="color:#d08770;">1
</span><span>
</span><span style="color:#65737e;">// Declaring variables
</span><span>var x, y, z
</span><span>
</span><span style="color:#65737e;">// Declaring constants
</span><span style="color:#b48ead;">const</span><span> G, M := 2e30, m := </span><span style="color:#d08770;">1</span><span>, c := 3e8
</span><span>
</span><span style="color:#65737e;">// Declaring expressions
</span><span style="color:#65737e;">// note the UI includes an optional MathQuill-style visual editor
</span><span style="color:#65737e;">// to insert expressions (which it then outputs with the CAS
</span><span style="color:#65737e;">// language) for convenience
</span><span>schwarzschild = (</span><span style="color:#d08770;">2 </span><span>* G * M) / c^</span><span style="color:#d08770;">2
</span><span>
</span><span style="color:#65737e;">// Declaring functions
</span><span style="color:#65737e;">// Note the same MathQuill-style visual editor is available
</span><span style="color:#96b5b4;">u</span><span>(x) </span><span style="color:#65737e;">// function prototype (useful for differential equations)
</span><span style="color:#96b5b4;">g</span><span>(x) = </span><span style="color:#d08770;">3 </span><span>* x </span><span style="color:#65737e;">// scalar-valued single variable
</span><span style="color:#96b5b4;">f</span><span>(x, y, z) = </span><span style="color:#d08770;">3 </span><span>* x^</span><span style="color:#d08770;">2 </span><span>+ </span><span style="color:#d08770;">5 </span><span>* y + z </span><span style="color:#65737e;">// scalar-valued multivariable
</span><span style="color:#96b5b4;">h</span><span>(x, y) = (</span><span style="color:#d08770;">5 </span><span>* x + </span><span style="color:#d08770;">4</span><span>, </span><span style="color:#d08770;">7 </span><span>* x + </span><span style="color:#d08770;">8</span><span>) </span><span style="color:#65737e;">// vector-valued
</span><span>
</span><span style="color:#65737e;">// Plot a function
</span><span style="color:#65737e;">// in the UI you can choose the domain and range
</span><span style="color:#65737e;">// with sliders and pan/zoom on the graph
</span><span>plot f
</span><span>
</span><span style="color:#65737e;">// Evaluating functions
</span><span style="color:#65737e;">// in the UI you can choose between a numerical answer (e.g. 5.114342)
</span><span style="color:#65737e;">// or a symbolic answer (e.g. sqrt(2) / 2)
</span><span style="color:#65737e;">// for numerical answers, any constants will be evaluated with their
</span><span style="color:#65737e;">// assigned numerical values
</span><span style="color:#96b5b4;">f</span><span>(</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">4</span><span>, </span><span style="color:#d08770;">3</span><span>)
</span><span>
</span><span style="color:#65737e;">// Taking derivatives without explicit evaluation
</span><span>dudx = diff u </span><span style="color:#65737e;">// here x doesn&#39;t need to be specified as it is the only variable
</span><span>
</span><span style="color:#65737e;">// Taking derivatives
</span><span>dfdx = diff f, x
</span><span style="color:#96b5b4;">dfdx</span><span>(</span><span style="color:#d08770;">2</span><span>, </span><span style="color:#d08770;">6</span><span>, </span><span style="color:#d08770;">1</span><span>)
</span><span>
</span><span style="color:#65737e;">// Taking the gradient
</span><span>grad_f = grad f
</span><span style="color:#96b5b4;">grad_f</span><span>(</span><span style="color:#d08770;">2</span><span>, </span><span style="color:#d08770;">6</span><span>, </span><span style="color:#d08770;">1</span><span>)
</span><span>
</span><span style="color:#65737e;">// Taking the indefinite integral symbolicallly
</span><span style="color:#65737e;">// This uses a neural network solver under the hood
</span><span>int_f = integrate f, x
</span><span style="color:#65737e;">// you can then evaluate the definite integral with
</span><span style="color:#96b5b4;">int_f</span><span>(</span><span style="color:#d08770;">6</span><span>) - </span><span style="color:#96b5b4;">int_f</span><span>(</span><span style="color:#d08770;">1</span><span>)
</span><span>
</span><span style="color:#65737e;">// Taking the definite integral symbolically
</span><span>integrate f, x, </span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">6
</span><span>
</span><span style="color:#65737e;">// Taking the definite integral
</span><span style="color:#65737e;">// When doing so, the answer is computed
</span><span style="color:#65737e;">// exclusively numerically
</span><span>quadrature f, x, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">5
</span><span>
</span><span style="color:#65737e;">// Create equation
</span><span>myeq = eq </span><span style="color:#d08770;">5 </span><span>* x^</span><span style="color:#d08770;">2 </span><span>+ </span><span style="color:#d08770;">8 </span><span>* x, </span><span style="color:#d08770;">78 </span><span>* x + </span><span style="color:#d08770;">5
</span><span>
</span><span style="color:#65737e;">// Solve equation
</span><span style="color:#65737e;">// in UI there is the option to solve
</span><span style="color:#65737e;">// symbolically or numerically
</span><span>solve myeq, x
</span><span>
</span><span style="color:#65737e;">// You can also use this as a lazy
</span><span style="color:#65737e;">// expression rearranger
</span><span>sch_radius_eq = eq r_s, schwarzschild
</span><span>solve sch_radius_eq, M </span><span style="color:#65737e;">// rearrange to get mass in terms of r_s
</span><span>
</span><span style="color:#65737e;">// Substitution
</span><span>subs myeq, x, </span><span style="color:#d08770;">5 </span><span>* y
</span><span>
</span><span style="color:#65737e;">// Using ans
</span><span style="color:#d08770;">5 </span><span>* x^</span><span style="color:#d08770;">2 </span><span>+ </span><span style="color:#d08770;">7 </span><span>* </span><span style="color:#96b5b4;">sin</span><span>(x)
</span><span>mynewexpr = ans
</span><span>
</span><span style="color:#65737e;">// Note substitution is always symbolic
</span><span style="color:#65737e;">// If you want to evaluate an expression
</span><span style="color:#65737e;">// (not a function) then use eval
</span><span style="color:#65737e;">// In eval you don&#39;t need to sub in the
</span><span style="color:#65737e;">// value of any constants, just the variables
</span><span>eval </span><span style="color:#d08770;">2 </span><span>* M * x^</span><span style="color:#d08770;">2 </span><span>+ </span><span style="color:#d08770;">3 </span><span>* t, { x = </span><span style="color:#d08770;">6</span><span>, t = </span><span style="color:#d08770;">0.1 </span><span>}
</span><span>
</span><span style="color:#65737e;">// Solving ordinary differential equations
</span><span style="color:#65737e;">// (can solve 1st or 2nd order ODEs)
</span><span style="color:#65737e;">// This uses a neural network solver under the hood
</span><span>mydiffeq = eq dudx, </span><span style="color:#d08770;">3 </span><span>* u * x
</span><span>dsolve eq </span><span style="color:#65737e;">// symbolic solver
</span><span>ndsolve eq </span><span style="color:#65737e;">// numerical solver - in UI there is option to show graph
</span><span>
</span><span style="color:#65737e;">// Note however that Elara CAS is not suited
</span><span style="color:#65737e;">// to complex numerical work or PDE solving,
</span><span style="color:#65737e;">// both of which Elara DE specialize in
</span></code></pre>
<p>The very minimalist syntax only works because you cannot nest built-in functions like <code>diff</code> and <code>integrate</code> within other functions, and those functions are delimitated by the end of the line.</p>
<h2 id="elara-studio">Elara Studio</h2>
<p>For custom project elara test path tracer - you first export the UV unwrapped 3D models from your modeling tool, then in the path tracer GUI you can add PBR materials and lights and render. This path tracer BTW is very non essential, as the project has literally no need of a path tracer (we can just use Blender), so really it is just a proof of project technology.</p>
<p>However this can be an alternative workflow - if the app provided a big built-in asset library (and one the user can add to) with things like materials, textures, lighting setups, models and so forth, then the renderer might actually be a good idea.</p>


	    </article>
    </main>

    <script>
    // Necessary until pulldown-cmark (which Zola depends on)
    // auto-appends a .tasklist class to all list items
    // that contain task lists
    document.querySelectorAll("input[type='checkbox']").forEach((el) => el.parentElement.classList.add("tasklist"));
    </script>

    <script defer src="https://elaraproject.github.io/elara-hub/katex/katex.min.js"></script>
    <script defer src="https://elaraproject.github.io/elara-hub/katex/contrib/auto-render.min.js"></script>

    <script>
    	// Loading KaTeX
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
              // customised options
              // • auto-render specific keys, e.g.:
              delimiters: [
                  {left: '$$', right: '$$', display: true},
                  {left: '$', right: '$', display: false},
                  {left: '\\(', right: '\\)', display: false},
                  {left: '\\[', right: '\\]', display: true}
              ],
              // • rendering keys, e.g.:
              throwOnError : false
            });
        });
    </script>
</body>
</html>
