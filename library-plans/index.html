
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elara Hub</title>
    
    <link rel="stylesheet" href="https://elaraproject.github.io/elara-hub/index.css">
    <!--KaTeX-->
    <link rel="stylesheet" href="https://elaraproject.github.io/elara-hub/katex/katex.min.css">

    <!--Open Sans-->
    <link rel="stylesheet" href="https://elaraproject.github.io/elara-hub/open-sans/open-sans.css">
    
</head>
<body>
    <nav>
    	<span class="header active">
    		<a href="https://elaraproject.github.io/elara-hub">Elara Hub</a> :: <a href="https://elaraproject.github.io/elara-hub/elara-hub-index/">Home</a>
    	</span>
    	<a class="header mobile-only" href="https://elaraproject.github.io/elara-hub/menu/">Menu</a>
    	<ul>
    	 
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/6-month-roadmap-1/">6-month roadmap 1</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/all-about-pdes/">All about partial differential equations</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/alt-de-solver/">Alternate differential equation solver</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/black-hole-raytracing/">Black hole raytracing</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/elara-gfx-continuing-work/">Elara GFX continuing work plan</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/elara-hub-creation/">Elara Hub creation plan</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/elara-hub-index/">Elara Hub Index</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/meta/">Elara Hub Meta</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/markdown-guide/">Elara markdown guide</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/elara-math-optimization/">Elara math optimization strategies</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/elara-ml-api/">Elara ML API proposal</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/elara-array-api-plan/">Elara-array API</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/extra/">Extra content</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/focusing-chamber-1/">Focusing chamber theoretical analysis 1</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/geometrized/">Geometrized units</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/h2-co2/">Hydrogen from CO2 production</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/integration-techniques/">Integration techniques</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/menu/">Menu (for mobile)</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/multivar/">Multivariable calculus guide</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/stages/">Project development stages</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/app-plans/">Project Elara app plans</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/library-plans/">Project Elara library plans</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/outreach-plan/">Project Elara Outreach Plan</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/funny/">Project humour and jokes</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/project-philosophy/">Project Philosophy</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/eval-christoffels/">Quickly evaluating the Christoffel symbols</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/relativity-hub/">Relativity Hub</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/future-extensions/">Speculative future extensions</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/standard-notation/">Standardized calculus notation</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/handbook-addthings/">Things to add to Elara Handbook</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/visualization-outreach/">Visualization-based outreach</a></li>
    	 
    	</ul>
    </nav>

    <main>
    	<article>
	    
	<h1>Project Elara library plans</h1>
	<!--eventually add in authors-->
	<h2 id="all-libraries">All libraries</h2>
<ul>
<li>Implement <a href="https://learning-rust.github.io/docs/custom-error-types/">custom error types</a> (this is already being implemented in <code>elara-gfx</code> pretty well) following <a href="https://mmapped.blog/posts/12-rust-error-handling.html">https://mmapped.blog/posts/12-rust-error-handling.html</a> - the correct approach is <strong>small enums</strong> of error categories rather than one humongous global error enum</li>
<li>Move to <a href="https://codeberg.org/">Codeberg</a> for hosting in the future and keep github as mirrors</li>
<li>All libraries that currently depend on <code>elara-log</code> should be able to make <code>elara-log</code> an optional dependency behind the <code>logging</code> feature flag. If disabled, they will simply use <code>println!</code> instead.</li>
</ul>
<h3 id="standard-library-architecture">Standard library architecture</h3>
<p>Above all else, project elara libraries (not apps!) should aim for minimalism and simplicity, in the style of <a href="https://github.com/tinygrad/tinygrad">tinygrad</a>. Where more features and more code isn't necessary, it's not written, or it's an optional feature. This does mean users need to write more code to compensate for things libraries don't themselves do, but it also gives the user a lot more control. The idea is the project elara libraries should never be giant megaframeworks like React.js or TensorFlow.</p>
<p>To do this, project elara libraries rely on the idea of implementation-agnostic code and backends. E.g. <code>elara-ui</code> does not come with a backend. There is, however, a few simple lines of boilerplate code that users can easily add to use <code>elara-gfx</code> as the backend. This allows <code>elara-ui</code> to have no dependencies (other than the optional logger). Usage would be like this:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">use </span><span>elara_ui::prelude::*;
</span><span style="color:#b48ead;">use </span><span>elara_gfx::prelude::*;
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>	</span><span style="color:#65737e;">// elara-gfx boilerplate...
</span><span>	</span><span style="color:#b48ead;">let</span><span> rect_renderer = RectRenderer::new();
</span><span>	</span><span style="color:#b48ead;">let</span><span> line_renderer = LineRenderer::new();
</span><span>	</span><span style="color:#b48ead;">let</span><span> text_renderer = TextRenderer::new();
</span><span>
</span><span>	</span><span style="color:#b48ead;">let</span><span> ui = </span><span style="color:#d08770;">UI</span><span>::new();
</span><span>	ui.</span><span style="color:#96b5b4;">set_layout</span><span>(</span><span style="color:#d08770;">5</span><span>, </span><span style="color:#d08770;">5</span><span>, </span><span style="color:#d08770;">5</span><span>, </span><span style="color:#d08770;">8</span><span>);
</span><span>	label = Label::new(&quot;</span><span style="color:#a3be8c;">Hi!</span><span>&quot;);
</span><span>	ui.</span><span style="color:#96b5b4;">add_element</span><span>(label)
</span><span>	</span><span style="color:#65737e;">// ui stuff...
</span><span>
</span><span>	</span><span style="color:#b48ead;">let</span><span> frame = ui.</span><span style="color:#96b5b4;">render</span><span>();
</span><span>	</span><span style="color:#b48ead;">for</span><span> el in frame.</span><span style="color:#96b5b4;">iter</span><span>() {
</span><span>		</span><span style="color:#b48ead;">match</span><span> el {
</span><span>			Component::Button =&gt; {
</span><span>				text_renderer.</span><span style="color:#96b5b4;">draw</span><span>([</span><span style="color:#d08770;">10</span><span>, </span><span style="color:#d08770;">5</span><span>], </span><span style="color:#d08770;">50</span><span>, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">5</span><span>);
</span><span>				line_renderer.</span><span style="color:#96b5b4;">draw</span><span>(</span><span style="color:#d08770;">50</span><span>, </span><span style="color:#d08770;">60</span><span>, </span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">false</span><span>);
</span><span>				</span><span style="color:#65737e;">// etc.
</span><span>			}
</span><span>		}
</span><span>	}
</span><span>}
</span></code></pre>
<p>Similarly, <code>elara-ml</code> doesn't have a backend either (though it does have an optional feature flag that gives it a CPU backend implementation that uses both <code>elara-math</code> and <code>elara-array</code>). The library docs give more examples of possible implementations, and custom backends can be written for <code>elara-ml</code> as well, which would probably be useful for custom machine learning hardware in the future.</p>
<p><code>elara-math</code> also doesn't have a backend - this allows its autodiff, integration, diff eq solvers, and special functions to work regardless of what backend provides the backing array.</p>
<p>The only library for which this mostly doesn't apply is <code>elara-array</code>, which comes with a built-in CPU and GPU backend by default (though the GPU backend is behind an optional feature flag). This is because <code>elara-array</code> itself is a very minimal library anyways, and all it implements is a n-dimensional array that supports elementwise operations. In addition, its CPU and GPU backends together only have 3 dependencies.</p>
<h2 id="elara-astro">elara-astro</h2>
<p><a href="https://crates.io/crates/nyx-space">https://crates.io/crates/nyx-space</a></p>
<h2 id="elara-md">elara-md</h2>
<p><code>elaramd</code> is a self-contained markdown to PDF converter for project elara. This converter skips the HTML generation step and directly takes markdown (with embedded LaTeX equations) and converts it to a styled PDF in the Elara Project style. This converter should include some common themes - academic (research paper), article, technical, etc. so that future project elara papers can be written in pure markdown instead of needing to be written in LaTeX.</p>
<h2 id="elara-presenter">elara-presenter</h2>
<p>Ideal presentation tool for project elara - takahashi method, write slides in markdown, the tool allows presenting the slides, like sent from suckless or <a href="https://ia.net/presenter">https://ia.net/presenter</a>. The tool should include markup for:</p>
<ul>
<li>Text slides
<ul>
<li>Heading-only slides</li>
<li>Text-only slides</li>
<li>Label and text slide (image is 100% height and text takes up remaining room)</li>
</ul>
</li>
<li>Whole page images</li>
<li>Code slides</li>
<li>KaTeX math slides</li>
<li>Good design for the slide themes</li>
</ul>
<h2 id="elara-ui">elara-ui</h2>
<p>Elara UI offers three different APIs:</p>
<ul>
<li>The widget API provides ready-to-use, styled widgets following Elara design conventions. However, widgets are not customizable</li>
<li>The component API provides basic building blocks of UIs that can then be joined together. They are flexible while not being overly verbose.</li>
<li>The draw API allows painting custom widgets. It is the lowest-level API.</li>
</ul>
<p>Elara UI requirements:</p>
<ul>
<li>Implementation of the entire Elara UI design system</li>
<li>Good performance, low footprint (but it does not have to be aggressively optimized)</li>
<li>Simple to use and easy to maintain</li>
<li>Battle-tested: to prove this, several apps meant for production use will be written in Elara UI to test its functionality (see the demo apps below)</li>
</ul>
<p>The single biggest inspiration for Elara UI's API is Gtk.</p>
<p>For Elara UI apps, the primary architecture will be a core-frontend approach. The functionality of the app will reside in the core, essentially library that contains all app functions. This allows the app to be run from the terminal, as well as controlled by scripting. The core should be able to do everything the app needs to do. Meanwhile, the frontend will communicate with the core and present the interface that the user will use to control the app. However, the frontend has no functionality of its own; all the functionality is in the core, which the frontend merely provides an interface to.</p>
<p>To integrate with this architecture, Elara UI is a retained-mode UI library, and uses the simplest API imaginable:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#65737e;">// 1. Create UI
</span><span style="color:#b48ead;">let mut</span><span> ui = </span><span style="color:#d08770;">UI</span><span>::new(</span><span style="color:#d08770;">1600</span><span>, </span><span style="color:#d08770;">1200</span><span>);
</span><span>
</span><span style="color:#65737e;">// 2. Create layouts
</span><span style="color:#b48ead;">let mut</span><span> left_sidebar = Layout::default();
</span><span>
</span><span style="color:#65737e;">// 3. Add elements with widgets API (easier) or 
</span><span style="color:#65737e;">// components API (more control) to layout
</span><span style="color:#b48ead;">let mut</span><span> sidebar_label = Label::new(&quot;</span><span style="color:#a3be8c;">Sidebar</span><span>&quot;);
</span><span style="color:#b48ead;">let mut</span><span> sidebar_list = List::from(&quot;</span><span style="color:#a3be8c;">Item {}</span><span>&quot;, </span><span style="color:#d08770;">0</span><span>..</span><span style="color:#d08770;">5</span><span>);
</span><span>
</span><span style="color:#65737e;">// 4. Add callbacks to widgets to make them interactive
</span><span style="color:#65737e;">// widgets can be bound to a state so that their appearance
</span><span style="color:#65737e;">// is linked to that state
</span><span>sidebar_list.</span><span style="color:#96b5b4;">on</span><span>(</span><span style="color:#b48ead;">move </span><span>|event| {
</span><span>    </span><span style="color:#b48ead;">match</span><span> event {
</span><span>        Event::Click =&gt; {
</span><span>            ui.</span><span style="color:#96b5b4;">close</span><span>();
</span><span>        },
</span><span>        _ =&gt; (),
</span><span>    }
</span><span>})
</span><span>
</span><span style="color:#65737e;">// 5. Add components to layout, and add layout to UI
</span><span>left_sidebar.</span><span style="color:#96b5b4;">add_element</span><span>(sidebar_label);
</span><span>left_sidebar.</span><span style="color:#96b5b4;">add_element</span><span>(sidebar_list);
</span><span>ui.</span><span style="color:#96b5b4;">add_element</span><span>(left_sidebar);
</span></code></pre>
<p>Testing demo apps:</p>
<ul>
<li>Make an analogue of <a href="https://sindresorhus.com/plain-text-editor">https://sindresorhus.com/plain-text-editor</a></li>
<li>Make a gui version of <a href="https://pypi.org/project/share-file-qr/">https://pypi.org/project/share-file-qr/</a></li>
<li>Make a previewer/slide shower based on <a href="https://en.wikipedia.org/wiki/Takahashi_method">https://en.wikipedia.org/wiki/Takahashi_method</a> like <code>sent</code> from the suckless project</li>
<li>Make a basic demo terminal based on <a href="https://github.com/dhanoosu/TkTerm">https://github.com/dhanoosu/TkTerm</a></li>
</ul>
<p>Follow tips from <a href="https://2d.graphics/">https://2d.graphics/</a></p>
<p>Tips for fast GPU rendering:</p>
<ul>
<li>Only render on user input/interaction, otherwise don't re-render frames (no immediate-mode UI that re-renders every frame)</li>
<li>Only re-render changed areas (&quot;damage tracking&quot;)
<ul>
<li>This requires caching the last render to a texture in memory and loading that texture on next frame, cropping out the region that was changed</li>
</ul>
</li>
<li>Must render on GPU</li>
<li>For repeated elements (e.g. long lists or tree views) caching is necessary</li>
</ul>
<p>design stuff:</p>
<p>For elaraui components - implement all the components that egui has in its demo</p>
<p>Elara UI should support a unified theme framework like https://github.com/hundredrabbits/Themes. Config specifies whether a theme is light or dark, and then specifies the colors of the theme. The Elara Design demo app can be used to preview the colors, and there is also an editor to visually edit themes. The Rust version of Elara UI (from which all the other versions are built from) will ship with a number of themes by default.</p>
<p>Cool apps to maybe port one day to <code>elara-ui</code> as demo applications:</p>
<ul>
<li><a href="https://github.com/FPurchess/blank">https://github.com/FPurchess/blank</a></li>
<li><a href="https://github.com/adileo/squirreldisk">https://github.com/adileo/squirreldisk</a></li>
<li><a href="https://github.com/spacedriveapp/spacedrive">https://github.com/spacedriveapp/spacedrive</a></li>
<li><a href="https://github.com/kkoomen/pointless">https://github.com/kkoomen/pointless</a></li>
</ul>
<h2 id="elara-math">elara-math</h2>
<p>Implement the following:</p>
<ul>
<li>Adam optimizer</li>
</ul>
<p>Current progress: see <a href="https://elaraproject.github.io/elara-hub/elara-math-optimization/">[Elara math optimization plan]</a></p>
<p>Elara-math will use elara-array for implementation of n-dimensional arrays, however everything else (e.g. diff eq solvers, FFT, special functions, quadrature, etc.) is custom-implemented.</p>
<p>In the future, do a &quot;blank rewrite&quot; - rewriting the entire library without looking at any reference github source code. Doing this often will help improve the code quality.</p>
<p>Autodiff implementations to look at:</p>
<ul>
<li><a href="https://github.com/ziap/autodiff/">https://github.com/ziap/autodiff/</a></li>
<li><a href="https://github.com/matiasbattocchia/simple-grad">https://github.com/matiasbattocchia/simple-grad</a></li>
<li><a href="https://github.com/conradludgate/autograd-rs/tree/main">https://github.com/conradludgate/autograd-rs/tree/main</a></li>
<li>(Nearly 1-1 reimplementation of Jax in Rust) <a href="https://getcode.substack.com/p/beyond-backpropagation-higher-order">https://getcode.substack.com/p/beyond-backpropagation-higher-order</a></li>
</ul>
<p>In the future elara-math should have a second functional API like Jax's that will be the primary API. This functional API has a <code>elara_math::grad()</code>function that transforms one function into a corresponding function for its derivative. Base this on how https://github.com/HIPS/autograd implements it. This is bc the current PyTorch-inspired API is basically only good for neural networks and wastes computational time creating graphs. One similar rust implementation to reference is <a href="https://github.com/ibab/rust-ad/blob/master/src/lib.rs">https://github.com/ibab/rust-ad/blob/master/src/lib.rs</a>.</p>
<p>Implement sparse matrices: <a href="https://crates.io/crates/sprs">https://crates.io/crates/sprs</a></p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Also add a numerical quadrature feature to <code>elara-math</code> to compute integrals:</li>
<li><input disabled="" type="checkbox"/>
Implement simpson's rule and Gauss-Konrod rule based on https://github.com/esa/torchquad for 1D case, Monte-Carlo integration for N-D case, as well as Trapezoidal and Romberg quadrature for integrating over discrete arrays</li>
<li><input disabled="" type="checkbox"/>
Add automatic integration - this is like automatic differentiation, only it takes a function and integrates its nth Taylor polynomial (which can be found exactly) - since unlike typical numerical integration it can be done to machine precision and thus doesn't suffer from numerical precision errors, it could be far more precise
<ul>
<li>Note: for this approach, automatic differentiation is necessary to compute the values of the derivative to construct the Taylor series</li>
<li>Techniques similar to Gauss-Konrod quadrature will probably be necessary to do range reduction for this approach to work well</li>
</ul>
</li>
</ul>
<p><a href="https://crates.io/crates/quad-rs/0.1.2">https://crates.io/crates/quad-rs/0.1.2</a></p>
<p>Also learn matrix calculus for <code>elara-math</code> from https://www.lesswrong.com/s/nMGrhBYXWjPhZoyNL/p/9L9XuXhLYBm47yYkf</p>
<p>Also eventually create a tensor algebra system like cadabra: <a href="https://cadabra.science/">https://cadabra.science/</a></p>
<p>Also add a monte-carlo solver for ODEs: <a href="https://jotterbach.github.io/content/posts/mc_ode/2018-08-08-MonteCarloODE/">https://jotterbach.github.io/content/posts/mc_ode/2018-08-08-MonteCarloODE/</a></p>
<h2 id="elara-ml">elara-ml</h2>
<p>Note: Elara ML is responsible for implementing the higher-level constructs for efficient machine learning (e.g. dense layers, convolution layers, model architectures, pretrained models, etc.) while Elara Math handles the underlying computations.</p>
<p>See <a href="https://elaraproject.github.io/elara-hub/elara-ml-api/">[Elara ML API proposal]</a></p>
<p><code>elara-ml</code> goals:</p>
<ul>
<li>Correct: a model written in PyTorch or TensorFlow should make equivalent predictions when ported to <code>elara-ml</code></li>
<li>Comprehensible: source code is in idiomatic Rust with lots of comments</li>
<li>Minimal: only the features you really need</li>
<li>Efficient: works fast, handles errors gracefully, and has an API with good developer experience, such as <code>model.summary()</code> visualizations (and isn't error-prone or overly verbose). It should also have good UI - e.g. progress bars on training.</li>
</ul>
<p>For <code>elara-ml</code> instead of a vec of two tensors (the weights and the biases) which is wasteful in terms of memory, it would be more efficient to just iterate separately on the weights and biases. So instead of:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">for</span><span> t in </span><span style="color:#bf616a;">self</span><span>.</span><span style="color:#96b5b4;">parameters</span><span>().</span><span style="color:#96b5b4;">iter</span><span>() {
</span><span>	t.</span><span style="color:#96b5b4;">update</span><span>(lr);
</span><span>}
</span></code></pre>
<p>instead do:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">for</span><span> t in </span><span style="color:#bf616a;">self</span><span>.</span><span style="color:#96b5b4;">weights</span><span>().</span><span style="color:#96b5b4;">iter</span><span>() {
</span><span>	t.</span><span style="color:#96b5b4;">update</span><span>(lr);
</span><span>}
</span><span>
</span><span style="color:#b48ead;">for</span><span> t in </span><span style="color:#bf616a;">self</span><span>.</span><span style="color:#96b5b4;">biases</span><span>().</span><span style="color:#96b5b4;">iter</span><span>() {
</span><span>	t.</span><span style="color:#96b5b4;">update</span><span>(lr);
</span><span>}
</span></code></pre>
<p>Also <code>elara-ml</code> should have dedicated <code>Input</code> and <code>Output</code> layers - they are basically normal Linear layers with a type alias, but they greatly improve in preventing errors in models.</p>
<p><code>elara-ml</code> should have both tests verifying correctness in code and in functionality. That is, part of its tests should be various neural networks that take in a random number of input features and labels (of different shapes, e.g. 500x3, 1x8, etc.) and should be able to predict the same features and labels with minimal configuration correctly at <strong>every point</strong>.</p>
<p><a href="https://github.com/utility-code/tinyDL">https://github.com/utility-code/tinyDL</a></p>
<h2 id="elara-gfx">elara-gfx</h2>
<p>See <a href="https://elaraproject.github.io/elara-hub/elara-gfx-continuing-work/">[Elara GFX continuing work]</a></p>
<p>Fixes:</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Fix the issue of the text rendering coordinates</li>
<li><input disabled="" type="checkbox" checked=""/>
Unified coordinate system for all primitives</li>
</ul>
<p>Features:</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Preliminary UI rendering</li>
<li><input disabled="" type="checkbox" checked=""/>
Save OpenGL rendering to image file for headless rendering (see <a href="https://lencerf.github.io/post/2019-09-21-save-the-opengl-rendering-to-image-file/">this</a>)</li>
<li><input disabled="" type="checkbox"/>
For a demo of both <code>elara-array</code> and <code>elara-gfx</code> - port the following pathtracers to Rust using only the project elara libraries:
<ul>
<li><input disabled="" type="checkbox"/>
<a href="https://github.com/li-plus/tinypt">https://github.com/li-plus/tinypt</a></li>
<li><input disabled="" type="checkbox"/>
<a href="http://www.kevinbeason.com/smallpt/">http://www.kevinbeason.com/smallpt/</a></li>
<li><input disabled="" type="checkbox"/>
<a href="https://github.com/vkoskiv/c-ray">https://github.com/vkoskiv/c-ray</a></li>
<li><input disabled="" type="checkbox"/>
The <a href="https://raytracing.github.io/">raytracing series</a></li>
</ul>
</li>
</ul>
<p>Look at <a href="https://lodev.org/lodepng/">https://lodev.org/lodepng/</a> and port the 500-line <code>picoPNG</code> into a Rust version for <code>elara-gfx</code>.</p>
<p>Implement several libraries on top of elara-gfx:</p>
<ul>
<li><code>elara-vg</code>: Fabric.js/Paper.js-like vector graphics library on top of elara-gfx, see <a href="http://fabricjs.com/fabric-intro-part-1">http://fabricjs.com/fabric-intro-part-1</a>, basically it implements the vector graphics parsing and processing and vector graphics operations, but it leaves all the rendering to <code>elara-gfx</code>, which allows it to render to any platform <code>elara-gfx</code> supports (basically all the platforms)</li>
<li><code>elara-ui</code>: minimal UI library on top of elara-gfx used for all the Elara apps, again thanks to the library it supports all the platforms <code>elara-gfx</code> supports (further details below)</li>
</ul>
<p><a href="https://zed.dev/blog/videogame">https://zed.dev/blog/videogame</a></p>
<p><code>elara-gfx</code> is meant to not include mathematical operations. However, for certain operations that do require handling arrays, elara-gfx will have a micro-implementation of basic math using purely functional programming. That means function signatures will look like this:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#65737e;">// Takes in matrix a of dims (M x N) and matrix b of dims (N x K)
</span><span style="color:#65737e;">// and write the result to matrix c
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">matmul</span><span>(</span><span style="color:#bf616a;">a</span><span>: &amp;[</span><span style="color:#b48ead;">f64</span><span>], </span><span style="color:#bf616a;">b</span><span>: &amp;[</span><span style="color:#b48ead;">f64</span><span>], </span><span style="color:#bf616a;">m</span><span>: </span><span style="color:#b48ead;">usize</span><span>, </span><span style="color:#bf616a;">n</span><span>: </span><span style="color:#b48ead;">usize</span><span>, </span><span style="color:#bf616a;">k</span><span>: </span><span style="color:#b48ead;">usize</span><span>, </span><span style="color:#bf616a;">c</span><span>: &amp;</span><span style="color:#b48ead;">mut</span><span> [</span><span style="color:#b48ead;">f64</span><span>]);
</span></code></pre>
<p><code>elara-gfx</code> should have three main APIs:</p>
<ul>
<li><code>GfxRenderer</code>, which is common graphics rendering layer like SDL (just with the ability to render both on the CPU and the GPU)</li>
<li><code>GPUCompute</code>, which is an OpenGL wrapper for GPU computations (like CUDA), inspired by <a href="https://github.com/DanRuta/GPGPU">this</a></li>
<li><code>Platform</code>, a very low-level API to do things like window creation, event listening, etc.</li>
</ul>
<p>Again, it aims to eventually be zero-dependency, which means that you do need to write OpenGL boilerplate initialization code yourself.</p>
<p>Crucially <code>elara-gfx</code> <strong>should not</strong> implement any math functions. That is what <code>elara-math</code> and <code>elara-array</code> does.</p>
<p>The <code>GfxRenderer</code> layer is able to draw basically anything graphics-related: </p>
<ul>
<li>Lines</li>
<li>Primitives
<ul>
<li>Rectangles</li>
<li>Circles</li>
<li>Triangles</li>
</ul>
</li>
<li>Text</li>
<li>Images
<ul>
<li>Typical textures</li>
<li>Optionally images created procedurally using elara-gfx shaders
<ul>
<li>The shaders are Rust closures that take in 32-bit vertex data and fragment data as input and output a 32-bit raster image</li>
<li>This means theoretically the shaders can render anything (even 3D objects or scenes)</li>
<li>However since the shaders are CPU-based they are slow, the OpenGL canvas is faster and should be used for intensive rendering tasks</li>
</ul>
</li>
</ul>
</li>
<li>Any 2D curve of arbitrary stroke and line color given a set of vertices</li>
<li>Any 2D shape of arbitrary stroke and fill given a set of vertices (which means e.g. if you want to draw a bezier curve, you need to write your algorithm to convert it to an array of vertices)</li>
<li>OpenGL canvas (GPU only, can run arbitrary OpenGL drawing commands)</li>
</ul>
<p>This means that to use <code>elara-gfx</code> is as simple as declaring:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">use </span><span>elara_gfx::{GfxRenderer, RenderBackend};
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#65737e;">// use the cross-platform CPU backend
</span><span>    </span><span style="color:#65737e;">// the backend is kind of like https://zserge.com/posts/fenster/
</span><span>    </span><span style="color:#b48ead;">let</span><span> ctx = GfxRenderer::create_ctx(RenderBackend::</span><span style="color:#d08770;">CPU</span><span>);
</span><span>    ctx.</span><span style="color:#96b5b4;">draw</span><span>(...);
</span><span>
</span><span>    </span><span style="color:#65737e;">// use the cross-platform OpenGL backend
</span><span>    </span><span style="color:#b48ead;">let</span><span> ctx = GfxRenderer::create_ctx(RenderBackend::OpenGL);
</span><span>    ctx.</span><span style="color:#96b5b4;">draw</span><span>(...);
</span><span>
</span><span>    </span><span style="color:#65737e;">// use the Apple-only Metal backend
</span><span>    </span><span style="color:#b48ead;">let</span><span> ctx = GfxRenderer::create_ctx(RenderBackend::Metal);
</span><span>    ctx.</span><span style="color:#96b5b4;">draw</span><span>(...);
</span><span>
</span><span>    </span><span style="color:#65737e;">// use the cross-platform Image backend
</span><span>    </span><span style="color:#65737e;">// this is most suitable to rendering to an image like a PNG
</span><span>    </span><span style="color:#b48ead;">let</span><span> ctx = GfxRenderer::create_ctx(RenderBackend::Image);
</span><span>    ctx.</span><span style="color:#96b5b4;">draw</span><span>(...);
</span><span>}
</span></code></pre>
<p>Elara GFX should eventually be zero-dependency (other than <code>elara-log</code>, but even that should be an optional feature flag), like <code>space-shooter.c</code>/<code>tigr</code>. This is a <em>very</em> long-term thing.</p>
<p>To implement this, I can make a simplified port of <code>tigr</code> to C with just the OpenGL parts, and then port it to Rust for a zero-dependency GL/platforming library. This is in line with the long-term goal of making the entire Elara Project zero-dependency.</p>
<h2 id="elara-array">elara-array</h2>
<p>More details in <a href="https://elaraproject.github.io/elara-hub/elara-array-api-plan/">[Elara-array API plan]</a></p>
<p><code>elara-array</code> should include its GPU backend as an optional feature. This speeds up compile times - because if it doesn't use the GPU backend, it has basically zero dependencies.</p>
<p>Implement the following:</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Working differential equations solvers</li>
<li><input disabled="" type="checkbox" checked=""/>
Working pretty-print for NdArrays</li>
<li><input disabled="" type="checkbox" checked=""/>
Working 1D pretty print</li>
<li><input disabled="" type="checkbox"/>
Python bindings (referencing tinynumpy for the code)</li>
<li><input disabled="" type="checkbox"/>
Nanoserde serialization to JSON for NumPy bridge</li>
<li><input disabled="" type="checkbox"/>
Tests for the library</li>
<li><input disabled="" type="checkbox"/>
Replace ndarray-rand with nanorand</li>
</ul>
<h2 id="elara-plot">elara-plot</h2>
<p>Can plot 2D real and complex-valued functions, 3D functions, and 4D functions, as well as their field equivalents.</p>
<p>Can also plot parametric lines and parametric surfaces, as well as vector-valued functions and vector fields</p>
<p>Visualizing 4D functions $f(\mathbb{R}^3) \to \mathbb{R}^4$: assign a color to each point in 3D space (density plots), such as:</p>
<ul>
<li><a href="https://www.math.brown.edu/tbanchof/multivarcalc2/multivarcalc3-1.html">https://www.math.brown.edu/tbanchof/multivarcalc2/multivarcalc3-1.html</a></li>
<li><a href="http://www.falstad.com/qmatom/">http://www.falstad.com/qmatom/</a></li>
</ul>


	    </article>
    </main>

    <script>
    // Necessary until pulldown-cmark (which Zola depends on)
    // auto-appends a .tasklist class to all list items
    // that contain task lists
    document.querySelectorAll("input[type='checkbox']").forEach((el) => el.parentElement.classList.add("tasklist"));
    </script>

    <script defer src="https://elaraproject.github.io/elara-hub/katex/katex.min.js"></script>
    <script defer src="https://elaraproject.github.io/elara-hub/katex/contrib/auto-render.min.js"></script>

    <script>
    	// Loading KaTeX
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
              // customised options
              // • auto-render specific keys, e.g.:
              delimiters: [
                  {left: '$$', right: '$$', display: true},
                  {left: '$', right: '$', display: false},
                  {left: '\\(', right: '\\)', display: false},
                  {left: '\\[', right: '\\]', display: true}
              ],
              // • rendering keys, e.g.:
              throwOnError : false
            });
        });
    </script>
</body>
</html>
