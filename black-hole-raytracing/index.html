
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elara Hub</title>
    
    <link rel="stylesheet" href="https://elaraproject.github.io/elara-hub/index.css">
    <!--KaTeX-->
    <link rel="stylesheet" href="https://elaraproject.github.io/elara-hub/katex/katex.min.css">

    <!--Open Sans-->
    <link rel="stylesheet" href="https://elaraproject.github.io/elara-hub/open-sans/open-sans.css">
    
</head>
<body>
    <nav>
    	<span class="header active">
    		<a href="https://elaraproject.github.io/elara-hub">Elara Hub</a> :: <a href="https://elaraproject.github.io/elara-hub/elara-hub-index/">Home</a>
    	</span>
    	<a class="header mobile-only" href="https://elaraproject.github.io/elara-hub/menu/">Menu</a>
    	<ul>
    	 
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/6-month-roadmap-1/">6-month roadmap 1</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/all-about-pdes/">All about partial differential equations</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/alt-de-solver/">Alternate differential equation solver</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/black-hole-raytracing/">Black hole raytracing</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/elara-gfx-continuing-work/">Elara GFX continuing work plan</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/elara-hub-creation/">Elara Hub creation plan</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/elara-hub-index/">Elara Hub Index</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/meta/">Elara Hub Meta</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/markdown-guide/">Elara markdown guide</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/elara-math-optimization/">Elara math optimization strategies</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/elara-ml-api/">Elara ML API proposal</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/elara-array-api-plan/">Elara-array API</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/extra/">Extra content</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/focusing-chamber-1/">Focusing chamber theoretical analysis 1</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/geometrized/">Geometrized units</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/h2-co2/">Hydrogen from CO2 production</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/integration-techniques/">Integration techniques</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/menu/">Menu (for mobile)</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/multivar/">Multivariable calculus guide</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/stages/">Project development stages</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/app-plans/">Project Elara app plans</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/library-plans/">Project Elara library plans</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/outreach-plan/">Project Elara Outreach Plan</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/funny/">Project humour and jokes</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/project-philosophy/">Project Philosophy</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/eval-christoffels/">Quickly evaluating the Christoffel symbols</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/relativity-hub/">Relativity Hub</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/future-extensions/">Speculative future extensions</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/standard-notation/">Standardized calculus notation</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/handbook-addthings/">Things to add to Elara Handbook</a></li>
    	 
    	 	<li><a href="https://elaraproject.github.io/elara-hub/visualization-outreach/">Visualization-based outreach</a></li>
    	 
    	</ul>
    </nav>

    <main>
    	<article>
	    
	<h1>Black hole raytracing</h1>
	<!--eventually add in authors-->
	<p>The general algorithm is this:</p>
<ul>
<li>Emit a bunch of rays from the camera at $(x, y)$ positions for each pixel in the final image</li>
<li>Calculate where they end up by numerically integrating along geodesics:
<ul>
<li>If they end up inside the event horizon, color should be black</li>
<li>Otherwise, color should be a sample color of whichever patch of night sky is in the direction they hit</li>
</ul>
</li>
<li>Set the color of the pixel located at position $(x, y)$ based on the previous step</li>
</ul>
<p>Note that this has no global illumination as it is <strong>not</strong> a path tracer. A path tracer would actually generate photorealistic images, but this is just a proof of concept.</p>
<p>I will write it in numpy first, then port it to Rust once I get it working.</p>
<hr />
<p>First, we position our black hole at the origin, $(0, 0, 0)$. We want to position our camera at $(6M, \pi / 2, \pi / 4)$ which should give a good view of the black hole.</p>
<p>Then, we want to produce our rays. Recall that a ray is typically given by:</p>
<p>$$
\vec R(t) = \vec O + \vec t D
$$</p>
<p>Here, $\vec O$ is the origin, and $\vec D$ is the direction vector of the ray. Note that the normalized velocity vector is exactly the same thing as the direction vector, so $\vec D$ can also be interpreted as a normalized velocity vector.</p>
<p>However, we have a slight complication. Recall that rays of light are bent in curved spacetime. Therefore, the simple ray equation does <strong>not</strong> apply. We instead need to numerically integrate to find the position of a ray at time $t$. To do this, we will use two derived equations from Schwarzschild spacetime:</p>
<p>$$
\frac{d^2 r}{ds^2} = -\frac{M}{r^2} + \frac{l^2}{r^3} - \frac{3Ml^2}{r^4}
$$</p>
<p>$$
\frac{d^2 \phi}{ds^2} = -\frac{2l}{r^3} \frac{dr}{ds}
$$
(there is a third equation, $\theta'' = 0$, but it's unnecessary to really mention it, as $\theta$ is constant)</p>
<p>We derived the two above equations from the radial motion equation and the $p_\phi$ constant of motion equation, and taking the derivative to get a second-order differential equation (which also fortunately cancels out the square roots and all the annoyances of squares appearing in derivative terms).</p>
<p>Here, we use the affine parameter $s$ as a substitute for time $t$, because light in General Relativity doesn't really experience time as it moves. So $s$ is like a &quot;substitute&quot; for time that we can effectively consider time, just for a light ray instead of an ordinary massive particle.</p>
<p>We will integrate from time $t_0$, when the rays leave the camera, to time $t_f$, where we can arbitrarily set $t_f$. We want to then find the position vector $\vec R(t)$ of the ray at $t_f$, or $\vec R(t_f)$. If $|\vec R(t_f)| &lt; 2M$, that means the ray vector is inside the event horizon, so we want to return a color of black. Otherwise, we sample the color of the patch of night sky the ray position vector hits. </p>
<p>Alternatively, we can simply find the vector $\vec W = \vec R(t_r) - \vec O$, where $\vec W$ is the vector pointing from the origin (where the camera is) to the ray vector position. By converting it to Cartesian coordinates and then normalizing this vector, we have the $(x, y, z)$ coordinates of the ray vector position in terms of the camera's world unit sphere. Now this is where equirectangular textures come in handy, because we can then take those $(x, y, z)$ coordinates and find the $(u, v)$ coordinates of the world texture, from which we can sample the color. The formula is:</p>
<p>$$
u = \frac{1}{2} + \frac{\operatorname{atan2}(W_z, W_x)}{2\pi}
$$</p>
<p>$$
v = \frac{1}{2} + \frac{\operatorname{arcsin}(W_y)}{\pi}
$$</p>
<p>For each pixel, we will repeat these steps - creating a ray, tracing the ray, and then finding the final color it outputs, and assigning that color to that pixel. Then, we will have our complete image of the black hole.</p>
<hr />
<p>$$
\left(\frac{dr}{d\phi}\right)^2 = \frac{r^4}{b^2} - \left(1 - \frac{r_s}{r}\right) \left(\frac{r^4}{a^2} + r^2\right)
$$</p>
<p>Now we take the limit as $m \to 0$, therefore $a \to \infty$ and $b \to \infty$, so:</p>
<p>$$
\left(\frac{dr}{d\phi}\right)^2 =  - \left(1 - \frac{r_s}{r}\right)r^2
$$</p>
<p>We take the derivative again to get a second-order differential equation that doesn't have a squared derivative:</p>
<p>$$
\frac{d^2 r}{d\phi^2} = \frac{1}{2} r_s - r
$$</p>
<hr />
<p>For debugging, we want to use the standard Newtonian $a = -\frac{GM}{r^2}$ equation to test.</p>
<p><a href="https://github.com/tyler-a-cox/black_hole_raytracer/tree/master">https://github.com/tyler-a-cox/black_hole_raytracer/tree/master</a></p>


	    </article>
    </main>

    <script>
    // Necessary until pulldown-cmark (which Zola depends on)
    // auto-appends a .tasklist class to all list items
    // that contain task lists
    document.querySelectorAll("input[type='checkbox']").forEach((el) => el.parentElement.classList.add("tasklist"));
    </script>

    <script defer src="https://elaraproject.github.io/elara-hub/katex/katex.min.js"></script>
    <script defer src="https://elaraproject.github.io/elara-hub/katex/contrib/auto-render.min.js"></script>

    <script>
    	// Loading KaTeX
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
              // customised options
              // • auto-render specific keys, e.g.:
              delimiters: [
                  {left: '$$', right: '$$', display: true},
                  {left: '$', right: '$', display: false},
                  {left: '\\(', right: '\\)', display: false},
                  {left: '\\[', right: '\\]', display: true}
              ],
              // • rendering keys, e.g.:
              throwOnError : false
            });
        });
    </script>
</body>
</html>
